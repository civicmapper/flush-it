{"version":3,"file":"esri-leaflet-gp.js","sources":["../package.json","../src/Tasks/Geoprocessing.js","../src/Services/Geoprocessing.js"],"sourcesContent":["{\n  \"name\": \"esri-leaflet-gp\",\n  \"description\": \"A Leaflet plugin for interacting with ArcGIS geoprocessing services.\",\n  \"version\": \"2.0.2\",\n  \"author\": \"John Gravois <jgravois@esri.com> (http://johngravois.com)\",\n  \"browser\": \"dist/esri-leaflet-gp-debug.js\",\n  \"bugs\": {\n    \"url\": \"https://github.com/jgravois/esri-leaflet-gp/issues\"\n  },\n  \"contributors\": [\n    \"John Gravois <jgravois@esri.com> (http://johngravois.com)\",\n    \"Nicholas Furness <nfurness@esri.com> (http://nixta.github.io/)\",\n    \"Patrick Arlt <parlt@esri.com> (http://patrickarlt.com)\",\n    \"Rowan Winsemius\"\n  ],\n  \"dependencies\": {\n    \"leaflet\": \"^1.0.0\",\n    \"esri-leaflet\": \"^2.0.0\"\n  },\n  \"devDependencies\": {\n    \"chai\": \"2.3.0\",\n    \"gh-release\": \"^2.0.0\",\n    \"highlight.js\": \"^8.0.0\",\n    \"http-server\": \"^0.8.5\",\n    \"isparta\": \"^3.0.3\",\n    \"istanbul\": \"^0.4.2\",\n    \"karma\": \"^0.12.24\",\n    \"karma-chai-sinon\": \"^0.1.3\",\n    \"karma-coverage\": \"^0.5.3\",\n    \"karma-mocha\": \"^0.1.0\",\n    \"karma-mocha-reporter\": \"^0.2.5\",\n    \"karma-phantomjs-launcher\": \"^0.2.0\",\n    \"karma-sourcemap-loader\": \"^0.3.5\",\n    \"mkdirp\": \"^0.5.1\",\n    \"phantomjs\": \"^1.9.17\",\n    \"rollup\": \"^0.25.4\",\n    \"rollup-plugin-json\": \"^2.0.0\",\n    \"rollup-plugin-node-resolve\": \"^1.4.0\",\n    \"rollup-plugin-uglify\": \"^0.1.0\",\n    \"semistandard\": \"^7.0.5\",\n    \"sinon\": \"^1.11.1\",\n    \"sinon-chai\": \"2.7.0\",\n    \"snazzy\": \"^2.0.1\",\n    \"uglify-js\": \"^2.6.1\",\n    \"watch\": \"^0.17.1\"\n  },\n  \"homepage\": \"https://github.com/jgravois/esri-leaflet-gp\",\n  \"jsnext:main\": \"src/EsriLeafletGP.js\",\n  \"jspm\": {\n    \"registry\": \"npm\",\n    \"format\": \"es6\",\n    \"main\": \"src/EsriLeafletGP.js\"\n  },\n  \"license\": \"Apache-2.0\",\n  \"main\": \"dist/esri-leaflet-gp-debug.js\",\n  \"readmeFilename\": \"README.md\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/jgravois/esri-leaflet-gp.git\"\n  },\n  \"scripts\": {\n    \"prebuild\": \"mkdirp dist\",\n    \"build\": \"rollup -c profiles/debug.js & rollup -c profiles/production.js\",\n    \"lint\": \"semistandard src/**/*.js | snazzy\",\n    \"prepublish\": \"npm run build\",\n    \"pretest\": \"npm run build\",\n    \"test\": \"npm run lint && karma start\",\n    \"release\": \"./scripts/release.sh\",\n    \"start\": \"watch 'npm run build' src & http-server -p 5000 -c-1 -o\"\n  }\n}\n","/*\nto do:\nsetParam([])\n*/\n\nimport L from 'leaflet';\nimport { Task as BaseTask, Util } from 'esri-leaflet';\n\nexport var Task = BaseTask.extend({\n\n  includes: L.Evented.prototype,\n\n  // setters: {}, we don't use these because we don't know the ParamName OR value of custom GP services\n  params: {},\n  resultParams: {},\n\n  initialize: function (options) {\n    // don't replace parent initialize\n    BaseTask.prototype.initialize.call(this, options);\n\n    // if path isn't supplied in options, try and determine if its sync or async to set automatically\n    if (!this.options.path) {\n      // assume initially, that service is synchronous\n      this.options.async = false;\n      this.options.path = 'execute';\n\n      // the parameters below seem wonky to me, but work for both CORS and JSONP requests\n      this._service.metadata(function (error, results) {\n        if (!error) {\n          if (results.executionType === 'esriExecutionTypeSynchronous') {\n            this.options.async = false;\n            this.options.path = 'execute';\n          } else {\n            this.options.async = true;\n            this.options.path = 'submitJob';\n          }\n          this.fire('initialized');\n        } else {\n          // if check fails, hopefully its synchronous\n          this.options.async = false;\n          this.options.path = 'execute';\n          return;\n        }\n      }, this);\n    } else {\n      // if path is custom, hopefully its synchronous\n      if (this.options.async !== true && this.options.path !== 'submitJob') {\n        this.options.async = false;\n      }\n    }\n  },\n\n  // doc for various GPInput types can be found here\n  // http://resources.arcgis.com/en/help/arcgis-rest-api/index.html#/GP_Result/02r3000000q7000000/\n\n  // set booleans, numbers, strings\n  setParam: function (paramName, paramValue) {\n    if (typeof paramValue === 'boolean') {\n      this.params[paramName] = paramValue;\n      return;\n    } else if (typeof paramValue !== 'object') { // strings, numbers\n      this.params[paramName] = paramValue;\n      return;\n    } else if (typeof paramValue === 'object' && paramValue.units) {\n      // pass through GPLinearUnit params unmolested\n      this.params[paramName] = paramValue;\n      return;\n    } else {\n      // otherwise assume its latlng, marker, bounds or geojson\n      if (paramName === 'geometry') {\n        this.params[paramName] = this._setGeometry(paramValue);\n      } else { // package up an array of esri features if the parameter name is anything other than geometry\n        var esriFeatures = {\n          'geometryType': this._setGeometryType(paramValue),\n          'features': []\n        };\n\n        if (paramValue.type === 'FeatureCollection') {\n          for (var i = 0; i < paramValue.features.length; i++) {\n            esriFeatures.features.push({'geometry': Util.geojsonToArcGIS(paramValue.features[i].geometry)});\n          }\n        } else {\n          esriFeatures.features.push({'geometry': this._setGeometry(paramValue)});\n        }\n\n        this.params[paramName] = esriFeatures;\n      }\n    }\n  },\n\n  // give developer opportunity to point out where the output is going to be available\n  setOutputParam: function (paramName) {\n    this.params.outputParam = paramName;\n  },\n\n  /* async elevation services need resultParams in order to return Zs (unnecessarily confusing)*/\n  gpAsyncResultParam: function (paramName, paramValue) {\n    this.resultParams[paramName] = paramValue;\n  },\n\n  // we currently expect a single geometry or feature (ported from: Tasks.Query._setGeometry)\n  _setGeometry: function (geometry) {\n    // convert bounds to extent and finish\n    if (geometry instanceof L.LatLngBounds) {\n      return L.esri.Util.boundsToExtent(geometry);\n    }\n\n    // convert L.Marker > L.LatLng\n    if (geometry.getLatLng) {\n      geometry = geometry.getLatLng();\n    }\n\n    // convert L.LatLng to a geojson point and continue;\n    if (geometry instanceof L.LatLng) {\n      geometry = {\n        type: 'Point',\n        coordinates: [geometry.lng, geometry.lat]\n      };\n    }\n\n    // handle L.GeoJSON, pull out the first geometry\n    if (geometry instanceof L.GeoJSON) {\n      // reassign geometry to the GeoJSON value  (we assume one feature is present)\n      geometry = geometry.getLayers()[0].feature.geometry;\n      // processedInput.geometryType = Util.geojsonTypeToArcGIS(geometry.type);\n      return Util.geojsonToArcGIS(geometry);\n    }\n\n    // Handle L.Polyline and L.Polygon\n    if (geometry.toGeoJSON) {\n      geometry = geometry.toGeoJSON();\n    }\n\n    // handle GeoJSON feature by pulling out the geometry\n    if (geometry.type === 'Feature') {\n      // get the geometry of the geojson feature\n      geometry = geometry.geometry;\n    }\n\n    // confirm that our GeoJSON is a point, line or polygon\n    if (geometry.type === 'Point' || geometry.type === 'LineString' || geometry.type === 'Polygon') {\n      return Util.geojsonToArcGIS(geometry);\n      // processedInput.geometryType = Util.geojsonTypeToArcGIS(geometry.type);\n    } else {\n      Util.warn('invalid geometry passed as GP input. Should be an L.LatLng, L.LatLngBounds, L.Marker or GeoJSON Point Line or Polygon object');\n    }\n  },\n\n  _setGeometryType: function (geometry) {\n    if (geometry instanceof L.LatLngBounds) {\n      return 'esriGeometryEnvelope';\n    }\n\n    // convert L.Marker > L.LatLng\n    if (geometry.getLatLng || geometry instanceof L.LatLng) {\n      return 'esriGeometryPoint';\n    }\n\n    // handle L.GeoJSON, pull out the first geometry\n    if (geometry instanceof L.GeoJSON) {\n      geometry = geometry.getLayers()[0].feature.geometry;\n      return Util.geojsonTypeToArcGIS(geometry.type);\n    }\n\n    // Handle L.Polyline and L.Polygon\n    if (geometry.toGeoJSON) {\n      geometry = geometry.toGeoJSON();\n    }\n\n    // handle GeoJSON feature by pulling out the geometry\n    if (geometry.type === 'Feature') {\n      // get the geometry of the geojson feature\n      geometry = geometry.geometry;\n    }\n\n    // confirm that our GeoJSON is a point, line or polygon\n    if (geometry.type === 'Point' || geometry.type === 'LineString' || geometry.type === 'Polygon') {\n      return Util.geojsonTypeToArcGIS(geometry.type);\n    } else if (geometry.type === 'FeatureCollection') {\n      return Util.geojsonTypeToArcGIS(geometry.features[0].type);\n    } else {\n      return null;\n    }\n  },\n\n  run: function (callback, context) {\n    this._done = false;\n\n    if (this.options.async === true) {\n      /* eslint-disable */\n      this._service.request(this.options.path, this.params, function (error, response) {\n        this._currentJobId = response.jobId;\n        this.checkJob(this._currentJobId, callback, context);\n      }, this);\n      /* eslint-enable */\n    } else {\n      return this._service.request(this.options.path, this.params, function (error, response) {\n        if (!error) {\n          if (response.results) {\n            callback.call(context, error, (response && this._processGPOutput(response)), response);\n          } else if (response.histograms) {\n            callback.call(context, error, response, response);\n          } else if (response.routes) {\n            callback.call(context, error, (response && this._processNetworkAnalystOutput(response)), response);\n          }\n        } else {\n          callback.call(context, error, null, null);\n        }\n      }, this);\n    }\n  },\n\n  checkJob: function (jobId, callback, context) {\n    var pollJob = function () {\n      /* eslint-disable */\n      this._service.request('jobs/' + jobId, {}, function polledJob (error, response) {\n        if (response.jobStatus === 'esriJobSucceeded') {\n          if (!this._done) {\n            this._done = true;\n            // to do:\n            // refactor to make an array of async requests for output\n            this._service.request('jobs/' + jobId + '/results/' + this.params.outputParam, this.resultParams, function processJobResult (error, response) {\n              callback.call(context, error, (response && this._processAsyncOutput(response)), response);\n            }, this);\n          }\n          window.clearInterval(counter);\n        } else if (response.jobStatus === 'esriJobFailed') {\n          callback.call(context, 'Job Failed', null);\n          window.clearInterval(counter);\n        }\n      }, this);\n      /* eslint-enable */\n    }.bind(this);\n\n    var counter = window.setInterval(pollJob, this._service.options.asyncInterval * 1000);\n  },\n\n  _processGPOutput: function (response) {\n    var processedResponse = {};\n\n    var results = response.results;\n    // grab syncronous results\n    if (this.options.async === false) {\n      // loop through results and pass back, parsing esri json\n      for (var i = 0; i < results.length; i++) {\n        /* jshint ignore:start */\n        processedResponse[results[i].paramName];\n        /* jshint ignore:end */\n        if (results[i].dataType === 'GPFeatureRecordSetLayer') {\n          var featureCollection = Util.responseToFeatureCollection(results[i].value);\n          processedResponse[results[i].paramName] = featureCollection;\n        } else {\n          processedResponse[results[i].paramName] = results[i].value;\n        }\n      }\n    } else { // grab async results slightly differently\n      processedResponse.jobId = this._currentJobId;\n      // var responseValue = response.value;\n    }\n\n    // if output is a raster layer, we also need to stub out a MapService url using jobid\n    if (this.options.async === true && response.dataType === 'GPRasterDataLayer') {\n      var baseURL = this.options.url;\n      var n = baseURL.indexOf('GPServer');\n      var serviceURL = baseURL.slice(0, n) + 'MapServer/';\n      processedResponse.outputMapService = serviceURL + 'jobs/' + this._currentJobId;\n    }\n\n    return processedResponse;\n  },\n\n  _processNetworkAnalystOutput: function (response) {\n    var processedResponse = {};\n\n    if (response.routes.features.length > 0) {\n      var featureCollection = Util.responseToFeatureCollection(response.routes);\n      processedResponse.routes = featureCollection;\n    }\n\n    return processedResponse;\n  },\n\n  _processAsyncOutput: function (response) {\n    var processedResponse = {};\n    processedResponse.jobId = this._currentJobId;\n\n    // if output is a raster layer, we also need to stub out a MapService url using jobid\n    if (this.options.async === true && response.dataType === 'GPRasterDataLayer') {\n      var baseURL = this.options.url;\n      var n = baseURL.indexOf('GPServer');\n      var serviceURL = baseURL.slice(0, n) + 'MapServer/';\n      processedResponse.outputMapService = serviceURL + 'jobs/' + this._currentJobId;\n    }\n\n    // if output is GPFeatureRecordSetLayer, convert to GeoJSON\n    if (response.dataType === 'GPFeatureRecordSetLayer') {\n      var featureCollection = Util.responseToFeatureCollection(response.value);\n      processedResponse[response.paramName] = featureCollection;\n    } else {\n      processedResponse[response.paramName] = response.value;\n    }\n\n    return processedResponse;\n  }\n\n});\n\nexport function task (options) {\n  return new Task(options);\n}\n\nexport default task;\n","import { Service as BaseService } from 'esri-leaflet';\nimport { Task } from '../Tasks/Geoprocessing';\n\nexport var Service = BaseService.extend({\n  options: {\n    asyncInterval: 1\n  },\n\n  createTask: function () {\n    return new Task(this, this.options);\n  }\n\n});\n\nexport function service (options) {\n  return new Service(options);\n}\n\nexport default service;\n"],"names":["task","options","Task","service","Service","BaseTask","extend","includes","L","Evented","prototype","params","resultParams","initialize","call","this","path","async","_service","metadata","error","results","executionType","fire","setParam","paramName","paramValue","units","_setGeometry","esriFeatures","geometryType","_setGeometryType","features","type","i","length","push","geometry","Util","geojsonToArcGIS","setOutputParam","outputParam","gpAsyncResultParam","LatLngBounds","esri","boundsToExtent","getLatLng","LatLng","coordinates","lng","lat","GeoJSON","getLayers","feature","toGeoJSON","warn","geojsonTypeToArcGIS","run","callback","context","_done","request","response","_processGPOutput","histograms","routes","_processNetworkAnalystOutput","_currentJobId","jobId","checkJob","pollJob","jobStatus","_processAsyncOutput","window","clearInterval","counter","bind","setInterval","asyncInterval","processedResponse","dataType","featureCollection","responseToFeatureCollection","value","baseURL","url","n","indexOf","serviceURL","slice","outputMapService","BaseService","createTask"],"mappings":"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"}